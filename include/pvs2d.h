/**
 * @file pvs2d.h
 * @author Latypov Ilya (id763281073@gmail.com)
 * @brief Potentially Visible Sets calculating library. 
 * @version 0.0.1
 * @date 2022-05-09
 * 
 * Библиотека вычисления Потенциально-Видимых Множеств.  
 * 
 * @copyright Copyright (c) 2022
 * 
 */
#ifndef PVS2D_H
#define PVS2D_H


// --------------------------------------------------------
//                       STRUCTURES
// --------------------------------------------------------

/**
 * @brief Прямая на плоскости между двумя точками. 
 * 
 * Представляет прямую на плоскости, проходящую через две точки. 
 * Точки должны иметь целочисленные координаты. 
 * Архитектура подразумевает, что на этой прямой будет лежать несколько отрезков,
 * все они хранятся в стеке `mems`.
 * Также обратите внимание, что прямая «ориентирована» от точки A (ax, ay) до точки B (bx, by).
 * Ориентация не влияет на производительность, но может
 * немного видоизменить получившиеся структуры.
 * 
 */
typedef struct PVS2D_Line {
	/**
	 * @brief Точки на которых лежит прямая. 
	 * 
	 * Четыре координаты двух точек, на которых лежит прямая. 
	 * 
	 */
	int ax, ay, bx, by;

	/**
	 * @brief Стэк всех отрезков на прямой
	 * 
	 * Стэк, представленный списком связности, содержащий все отрезки, лежащие на прямой.
	 * 
	 */
	struct PVS2D_SegStack* mems;
} PVS2D_Line;

/**
 * @brief Отрезок, лежащий на прямой. 
 * 
 * Представляет отрезок, лежащий на определенной прямой. Конечные точки отрезка
 * представлены переменными tStart и tEnd, каждая из которых представляет
 * точку на параметрической прямой, tStart для начала отрезка и tEnd
 * для конца. Точка, лежащая на параметрической прямой с параметром `t`, может быть
 * представлен как
 * `(line->bx * t + line->ax * (1 - t), line->by * t + line->ay * (1 - t))`
 * Обратите внимание, что отрезок ориентирован в ту же сторону, как и прямая на которой он лежит.
 * 
 */
typedef struct PVS2D_Seg {
	/**
	 * @brief Прямая. 
	 * 
	 * Прямая, на которой лежит отрезок. 
	 * 
	 */
	struct PVS2D_Line* line;

	/**
	 * @brief Параметры точек концов отрезка. 
	 * 
	 * Параметры точек начала и конца отрезка. Обязательно выполнение условия `tStart < tEnd`
	 * 
	 */
	double tStart, tEnd;

	/**
	 * @brief Флаг прозрачности. 
	 * 
	 * Флаг, определяющий, является ли отрезок прозрачным (0, если прозрачный) или 
	 * непрозрачным (1, если непрозрачный). Независимо от того, прозрачен отрезок или нет, 
	 * он так или иначе будет разделять пространство во время расчета дерева Двоичного Разделения 
	 * пространства, однако при построении порталов непрозрачные отрезки будут перекрывать прозрачные, 
	 * и на месте пустого пространства будут сгенерированы прозрачные порталы. 
	 * 
	 */
	int opq;
} PVS2D_Seg;

/**
 * @brief Стэк отрезков. 
 * 
 * Представляет собой связный список отрезков. 
 * 
 */
typedef struct PVS2D_SegStack {
	/**
	 * @brief Отрезок. 
	 * 
	 */
	struct PVS2D_Seg* seg;

	/**
	 * @brief Указатель на следующий элемент стэка. 
	 * 
	 * Указатель на следующий элемент списка связности. 
	 * 
	 */
	struct PVS2D_SegStack* next;
} PVS2D_SegStack;

/**
 * @brief Вершина дерева Двоичного Разделения пространства. 
 * 
 * Представляет вершину дерева Двоичного Разделения пространства (BSP-дерева). Содержит прямую, которая 
 * делит пространство на две части, указатели на корни левого и правого поддерева, а также 
 * индексы листов, которые используются вместо вершин, если правое или левое подпространство 
 * пусто. По-скольку разделительная прямая также находится в пределах подпространства текущей 
 * вершины, она имеет начало и конец (которые могут быть бесконечно удаленными). Структура также 
 * имеет стэк всех отрезков, которые лежат на разделительной прямой. 
 * 
 */
typedef struct PVS2D_BSPTreeNode {
	/**
	 * @brief Указатели на корни левого и правого поддеревьев. 
	 * 
	 * Указатели на корни левого и правого поддеревьев. Их подпространство находится слева и справа 
	 * от разделительной прямой соответственно. Каждый из этих указателей может быть равен NULL, 
	 * указывая, что левое или правое подпространство не имеют отрезков строго внутри, соответственно 
	 * являясь листом. В таком случае `leftLeaf` или `rightLeaf` соответственно должны содержать 
	 * корректный индекс листа. 
	 * 
	 */
	struct PVS2D_BSPTreeNode *left, *right;

	/**
	 * @brief Индексы левого и правого листа. 
	 * 
	 * Например, если текущая вершина не имеет левого поддерева, 
	 * `leftLeaf` должен содержать индекс листа, который является левым подпространством. 
	 * 
	 */
	unsigned int leftLeaf, rightLeaf;

	/**
	 * @brief Разделительная прямая. 
	 * 
	 * Прямая, которая делит подпространство вершины на две части. Таким образом левое подпространство 
	 * находится слева от разделительной прямой, и правое - справа. В данном контексте лево и право 
	 * берутся относительно нахождения в точке А разделительной прямой, направляя взгляд на точку B. 
	 * 
	 */
	struct PVS2D_Line* line;

	/**
	 * @brief Стэк отрезков, лежащих на разделительной прямой. 
	 * 
	 * Стэк всех отрезков, лежащих на разделительной прямой. 
	 * 
	 */
	struct PVS2D_SegStack* segs;
	
	/**
	 * @brief Параметры точек концов разделительной прямой. 
	 * 
	 * Параметры точек концов разделительной прямой. Отрезок, заключенный между этими точками 
	 * должен лежать полностью внутри подпространства текущей вершины. Также  
	 * должно выполняться условие `tSplitStart` < `tSplitEnd`, однако, в отличие от тех, `tSplitStart` 
	 * может иметь значение `-INFINITY` и `tSplitEnd` может иметь значение `INFINITY`. 
	 * 
	 */
	double tSplitStart, tSplitEnd;

	/**
	 * @brief Стэк порталов, лежащих на разделительной прямой. 
	 * 
	 * Стэк порталов, лежащих на разделительной прямой. Никакие два портала не должны иметь общих точек 
	 * помимо концов, и любые два соседних портала должны иметь общий конец (таким образов все порталы 
	 * выстраиваются в "цепь"). 
	 * 
	 */
	struct PVS2D_PortalStack* portals;
} PVS2D_BSPTreeNode;

/**
 * @brief Стэк порталов. 
 * 
 * Представляет собой связный список, содержащий порталы. 
 * Также каждый элемент предоставляет информацию, является ли в данном контексте портал 
 * левым или правым. 
 * 
 */
typedef struct PVS2D_PortalStack {
	/**
	 * @brief Портал. 
	 * 
	 */
	struct PVS2D_Portal* portal;

	/**
	 * @brief Указатель на следующий элемент
	 * 
	 */
	struct PVS2D_PortalStack* next;

	/**
	 * @brief Флаг относительной позиции портала. 
	 * 
	 * Флаг, используемый во время построения порталов, используется чтобы указать, 
	 * находится ли подпространство текущей вершины BSP-дерева слева от отрезка (1, если так), 
	 * или справа (0, если так)
	 * 
	 */
	int left;
} PVS2D_PortalStack;

/**
 * @brief Портал между двумя листами. 
 * 
 * Представляет портал между двумя листами. По сути, портал - модификация Отрезка, которая содержит 
 * индексы правого и левого листа. Любой портал должен проходить по границе ровно двух листов - 
 * одного слева и одного справа. 
 * 
 */
typedef struct PVS2D_Portal {
	/**
	 * @brief Отрезок, представляющий портал. 
	 * 
	 */
	struct PVS2D_Seg seg;

	/**
	 * @brief Листы портала. 
	 * 
	 * Индексы левого и правого листов, по границам которых проходит портал.
	 * 
	 */
	unsigned int leftLeaf, rightLeaf;
} PVS2D_Portal;

/**
 * @brief Стэк ребер вершины графа листов. 
 * 
 * Представляет стэк (связный список) ребер вершины графа листов, т.е. является списком связности 
 * (не путать со связным списком) вершины графа. Поскольку все соединения
 * между листами идут через порталы, каждое ребро в графе представлено каким-то порталом.
 * 
 */
typedef struct PVS2D_LeafGraphEdgeStack {
	/**
	 * @brief Вершина, из которой исходит ребро
	 * 
	 */
	struct PVS2D_LeafGraphNode* node;

	/**
	 * @brief Указатель на следующий элемент стэка
	 * 
	 */
	struct PVS2D_LeafGraphEdgeStack* next;

	/**
	 * @brief Портал, представляющийся ребром. 
	 * 
	 * Посколько все ребра в графе проходят между двумя примыкающими друг к другу листами, 
	 * каждое ребро может быть представлено порталом, проходящим по границе между этими листами, 
	 * которым и является `prt`
	 * 
	 */
	struct PVS2D_Portal* prt;
} PVS2D_LeafGraphEdgeStack, PVS2D_LGEdgeStack;

/**
 * @brief Вершина в графе смежности листов. 
 * 
 * Представляет вершину в графе смежности листов. Также содержит в себе информацию о листе, 
 * например, считается ли этот лист "вне играбельной зоны".
 * 
 */
typedef struct PVS2D_LeafGraphNode {
	/**
	 * @brief Индекс листа. 
	 * 
	 */
	unsigned int leaf;

	/**
	 * @brief Флаг "вне играбельной зоны"
	 * 
	 * Этот флаг указывает, является ли этот "вне играбельной зоны". Этот 
	 * флаг устанавливается автоматически, основываясь на порталах, идущих по границе листа. 
	 * Если на границе листа есть хотя бы один портал бесконечной длины - этот лист указывается 
	 * как "вне играбельной зоны". Также, если лист имеет соседний лист "вне играбельной зоны", соединяясь 
	 * с ним прозрачным порталом - то оба листа будут помечены "вне играбельной зоны". Таким образом 
	 * достигается верность факта, что из "играбельной зоны" невозможно увидеть бесконечные порталы. 
	 * Причина, по которой этот флаг существует, в том, что невозможно расчитать Потенциально Видимое 
	 * множество (PVS) листа, содержащего бесконечные порталы. 
	 * 
	 */
	char oob;

	/**
	 * @brief Стэк ребер вершины графа
	 * 
	 */
	struct PVS2D_LeafGraphEdgeStack* adjs;
} PVS2D_LeafGraphNode;

/**
 * @brief Стэк вершин графа
 * 
 * Представляет собой стэк (связный список) вершин графа. 
 * 
 */
typedef struct PVS2D_LeafGraphNodeStack {
	/**
	 * @brief Вершина графа. 
	 * 
	 */
	PVS2D_LeafGraphNode* node;

	/**
	 * @brief Указатель на следующий элемент стэка. 
	 * 
	 */
	struct PVS2D_LeafGraphNodeStack* next;
} PVS2D_LeafGraphNodeStack, PVS2D_LGNodeStack;
 
// --------------------------------------------------------
//                  INTERFACE FUNCTIONS
// --------------------------------------------------------

/**
 * @brief Строит дерево Двоичного Разделения пространства. 
 * 
 * Строит дерево Двоичного Разделения пространства используя данный массив отрезков. Массив 
 * должен иметь следующую структуру: `segsC` блоков по 5 целых чисел: `ax, ay, bx, by, opq`, 
 * `ax, ay` - координаты начала отрезка, 
 * `bx, by` - координаты конца отрезка, 
 * `opq` - флаг, указывающий, является ли отрезок прозрачным (0 если так) или нет (1 если так). 
 * Возвращает 0 если построение выполнено успешно, другое число если нет. 
 * 
 * @param segs Массив отрезков. 
 * @param segsC Количество блоков. 
 * @param rootDest Указатель на вершину BSP-дерева, куда будет записан результат построения. 
 * @return 0 если успешно, другое число если нет. 
 */
int PVS2D_BuildBSPTree(
	int* segs, unsigned int segsC,
	PVS2D_BSPTreeNode* rootDest
);

/**
 * @brief Находит индекс листа, в котором находится данная точка. 
 * 
 * @param root Указатель на корень BSP-дерева. 
 * @param x X координата точки. 
 * @param y Y координата точки. 
 * @return Индекс листа, в котором находится данная точка. 
 */
unsigned int PVS2D_FindLeafOfPoint(
	PVS2D_BSPTreeNode* root,
	double x, double y
);

/**
 * @brief Указывает индексы листов, через которые проходит данный отрезок. 
 * 
 * Указывает индексы листов, через которые проходит данный отрезок. Результат записывается 
 * в "битсет" (массив char'ов, i-тый char является 1 если отрезок проходит через i-тый лист). 
 * 
 * @param root Указатель на корень BSP-дерева. 
 * @param ax X координата начала отрезка
 * @param ay Y координата начала отрезка
 * @param bx X координата конца отрезка
 * @param by Y координата конца отрезка
 * @param leafbitset Битсет, в который функция выведет результат. Должен содержать не меньше элементов, 
 * чем число листов в дереве. 
 */
void PVS2D_FindLeafsOfSegment(
	PVS2D_BSPTreeNode* root,
	double ax, double ay, double bx, double by,
	char* leafbitset
);

/**
 * @brief Строит порталы в BSP-дереве. 
 * 
 * Строит порталы внутри BSP-дерева, по сути заполняя поле `portals` в вершинах. 
 * Возвращает 0 если построение успешно, другое число иначе. 
 * 
 * @param root Указатель на корень дерева. 
 * @return 0 если успешно, другое число если нет. 
 */
int PVS2D_BuildPortals(
	PVS2D_BSPTreeNode* root
);

/**
 * @brief Строит граф смежности листов. 
 * 
 * Строит граф смежности листов используя построенные в BSP-дереве порталы. 
 * Соответственно, дерево должно иметь порталы построенными с помощью `PVS2D_BuildPortals`.
 * Возвращает массив из вершин графа, размер массива равен числу листов в графе, также возвращает 
 * само число. 
 * 
 * @param root Указатель на корень дерева. 
 * @param nodesCDest Указатель на `unsigned int`, куда будет записано число листов в дереве. 
 * @return Указатель на первый элемент массива вершин графа. 
 */
PVS2D_LeafGraphNode* PVS2D_BuildLeafGraph(
	PVS2D_BSPTreeNode* root,
	unsigned int* nodesCDest
);

/**
 * @brief Вычисляет Потенциально Видимое множество (PVS) листа. 
 * 
 * @param node Вершина графа, содержащая лист, PVS которого надо вычислить. 
 * @param leafC Количество листов в дереве. 
 * @return Битмаску - массив char'ов, где i-тый char равен 1, если i-тый лист видим из данного. 
 */
char* PVS2D_GetLeafPVS(
	PVS2D_LeafGraphNode* node, unsigned int leafC
);

#endif